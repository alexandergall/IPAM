#!/usr/bin/perl

my $base_dir;
BEGIN {
  $base_dir = '/home/noc/IPAM';
  if (exists $ENV{IPAM_BASE}) {
    $base_dir = $ENV{IPAM_BASE};
  }
}
use strict;
use warnings;
use lib "$base_dir/lib/perl5";
use IPAM 0.01;
use NetAddr::IP;
use Getopt::Long;
use open qw/:std :utf8/;

my %opt = ( 'default-domain' => 'switch.ch.' , recurse => 0);
my $indent_unit = 2;
my %af_to_name = ( 4 => 'IPv4', 6 => 'IPv6' );
my (%visited_fqdns, %visited_prefixes, %visited_hosts);

sub usage() {
  print <<"EOF";
usage: $0 [--default-domain=<domain>] [--detail] [--no-stub-recurse] [--recurse=<level>] <fqdn> | <address> | <prefix> ...
EOF
exit(1);
}

sub name_info($$);
sub prefix_info($$);
sub indent($$);
sub detail($$);
sub print_pf_registry($$$);

GetOptions(\%opt, "default-domain=s", "detail", "recurse=i", 'warnings', 'no-stub-recurse')
  or usage();
@ARGV >= 1 or usage();
$opt{recurse}++;
$opt{recurse} < 0 and $opt{recurse} = 0;
$opt{'default-domain'} =~ /\.$/ or 
  die "The default domain must end with a dot.\n";
my $file = "$base_dir/ipam.xml";
system("cd $base_dir && make --silent validate") == 0 or die;
my $ipam = IPAM->new({ verbose => undef, base_dir => $base_dir,
		       validate => undef, warnings => $opt{warnings}});
$ipam->load($file);

foreach my $item (@ARGV) {
  if ($item =~ /(\d+\.\d+\.\d+\.\d+|:|\/)/) {
    my $ip = NetAddr::IP->new($item) or die "Malformed address $item";
    prefix_info($ip, 0);
  } else {
    name_info($item, 0);
  }
}

sub name_info($$) {
  my ($fqdn, $indent) = @_;
  my $recurse_save = $opt{recurse};
  $opt{recurse} > 0 and $opt{recurse}--;
  unless ($fqdn =~ /\.$/) {
    $fqdn .= '.';
    unless ($fqdn =~ /\.$opt{'default-domain'}$/) {
      $fqdn .= $opt{'default-domain'};
    }
  }
  unless (exists $visited_fqdns{$fqdn}) {
    $visited_fqdns{$fqdn} = 1;
    indent($indent++, "The domain name $fqdn\n");
    my $info = $ipam->nameinfo($fqdn);
    if ($info->{network}) {
      my $network = $info->{network};
      indent($indent, "Is a subnet.\n");
      if ($opt{detail}) {
	detail($network, $indent+1);
	if (my @hosts = $network->hosts()) {
	  indent($indent+1, "It contains the hosts\n");
	  foreach my $host (sort(@hosts)) {
	    indent($indent+2, $host->name()."\n");
	    $opt{recurse} and name_info($host->name(), $indent+3);
	  }
	}
      }
    }
    if ($info->{block}) {
      foreach my $prefix (@{$info->{block}}) {
	indent($indent, "Is a"
	       .($prefix->is_stub() ? ' stub network' : 'n address block')
	       ." that defines the prefix ".$prefix->name()."\n");
	detail($prefix, $indent+1);
	$opt{recurse} and prefix_info($prefix->ip(), $indent+1);
      }
    }
    if ($info->{iid}) {
      my $iid = $info->{iid};
      indent($indent, "Is the IPv6 interface-identifier "
	     .$iid->ip()->addr()."\n");
      if ($opt{detail}) {
	detail($iid, $indent+1);
	$iid->use() or indent($indent+1, "It is configured to be ignored "
			      ."for address assignment.\n");
      }
    }
    if ($info->{zone}) {
      my $zone = $info->{zone};
      indent($indent, "Is a DNS zone\n");
      detail($zone, $indent+1);
      $opt{recurse} and map { $_->print(\*STDOUT, ($indent+1)*$indent_unit,
					$opt{detail}) }
	(sort { $a->name() cmp $b->name() } $zone->domains());
    }
    if ($info->{host}) {
      foreach my $host (@{$info->{host}}) {
	indent($indent, "Is a host that belongs to the network "
	       .$host->network()->name()."\n");
	if ($opt{detail}) {
	  detail($host, $indent+1);
	  foreach my $address ($host->addresses()) {
	    my $canonical_host = $address->canonical_host();
	    indent($indent+1, "It is ".
		   ((defined $canonical_host and $canonical_host == $host) ?
		    'the canonical' : 'a')." name for the address "
		   .$address->name()."\n");
	    alternatives($indent+1, IPAM::Alternative::MAP_ADDRESS,
			 $host, $address);
	    $opt{recurse} and prefix_info($address->ip(), $indent+2);
	  }
	  map { indent($indent+1, $_->name()." is an alias for the host.\n");
		alternatives($indent+1, IPAM::Alternative::MAP_ALIAS,
			     $host, $_);
		$opt{recurse} and name_info($_->name(), $indent+2); }
	    $host->aliases();
	  map { indent($indent+1, "It is hosted on ".$_->name()."\n");
		$opt{recurse} and name_info($_->name(), $indent+2); }
	    $host->hosted_on();
	}
      }
    }
    if ($info->{alias}) {
      foreach my $host (@{$info->{alias}}) {
	indent($indent, "Is an alias for the host "
	       .$host->name() ."\n");
	alternatives($indent, IPAM::Alternative::MAP_ALIAS,
		     $host, $host->alias_registry()->lookup($fqdn));
	detail($host->alias_registry()->lookup($fqdn), $indent+1);
	$opt{recurse} and name_info($host->name(), $indent+1);
      }
    }
    my ($zone, $rel_name) = $ipam->registry(IPAM::REG_ZONE)->lookup_fqdn($fqdn);
    if ($zone) {
      if (my $domain = $zone->lookup_domain($rel_name)) {
	indent($indent, "Owns the following DNS records in the zone "
	       .$zone->name()."\n");
	$domain->print(\*STDOUT, ($indent+1)*$indent_unit, $opt{detail});
      } else {
	indent($indent, "Belongs to the zone ".$zone->name()
	       .", but there are no DNS records associated with it.\n");
      }
    } else {
      indent($indent, "Does not belong to any of the configured zones.\n")
    }
  }
  $opt{recurse} = $recurse_save;
}

sub prefix_info($$) {
  my ($ip, $indent) = @_;
  my $recurse_save = $opt{recurse};
  $opt{recurse}--;
  $opt{recurse} < 0 and $opt{recurse} = 0;
  unless (exists $visited_prefixes{$ip->addr()}) {
    $visited_prefixes{$ip->addr()} = 1;
    my $type = $ip->bits() == $ip->masklen() ? 'address' : 'prefix';
    my ($prefix, @path) =
      $ipam->address_map()->lookup_by_ip($ip);
    unless ($prefix or @path) {
      if (my $iid = $ipam->registry(IPAM::REG_IID)->lookup_by_ip($ip)) {
	indent($indent, $ip->addr()." is an IPv6 interface identifier.\n");
	detail($iid, $indent+1);
	indent($indent+1, "It is assigned to host ".$iid->name()."\n");
	$opt{recurse} and name_info($iid->name(), $indent+1);
      } else {
	print "The database contains no information about the $type $ip\n";
      }
    } else {
      if ($prefix) {
	if ($prefix->isa('IPAM::Address')) {
	  indent($indent, $prefix->name()." is an address.\n");
	  detail($prefix, $indent+1);
	  if (my $canonical_host = $prefix->canonical_host()) {
	    indent($indent+1, "It has the canonical name ".
		   $canonical_host->name()."\n");
	  } else {
	    indent($indent+1, "It has no canonical name.\n");
	  }
	  map { indent($indent+1, "It is assigned to the host ".
		       $_->name()."\n");
		alternatives($indent+2, IPAM::Alternative::MAP_ADDRESS,
			     $_, $prefix);
		$opt{recurse} and name_info($_->name(), $indent+2) }
	    $prefix->hosts();
	} else {
	  if (my $network = $prefix->network()) {
	    indent($indent, $prefix->name()." is assigned to the subnet "
		   .$network->name()."\n");
	  } else {
	    indent($indent, $prefix->name()." is assigned to the "
		   .($prefix->is_stub() ? 'stub network ' : 'address block ')
		   .$prefix->id()."\n");
	  }
	  detail($prefix, $indent+1);
	  $opt{recurse} and
	    print_pf_registry($prefix->registry(), $indent+1, $prefix->af());
	}
      } else {
	indent($indent, "There is no exact match for the $type $ip\n");
      }
      if (@path) {
	$indent += 1;
	indent($indent++, "It is contained in a branch of the address map\n");
	foreach my $element (@path) {
	  indent($indent++, sprintf "%-20s  %s\n", $element->name(),
		 $element->id());
	}
      }
    }
  }
  $opt{recurse} = $recurse_save;
}

sub indent($$) {
  my ($level, $msg) = @_;
  print ' 'x($level*$indent_unit).$msg;
}

sub detail($$) {
  my ($node, $indent) = @_;
  return unless $opt{detail};
  my ($file, $line) = $node->nodeinfo();
  ($file and $line) and indent($indent, "It is defined at $file, line $line\n");
  my $desc = $node->description();
  $desc and indent($indent, "It has the description: $desc\n");
}

sub print_pf_registry($$$) {
  my ($reg, $indent, $af) = @_;
  my $recurse_save = $opt{recurse};
  $opt{recurse}--;
  $opt{recurse} < 0 and $opt{recurse} = 0;
  my $next = $reg->iterator(sub { my ($a, $b) = @_; $b->ip() cmp $a->ip(); },
			    $af);
  while (my $prefix = $next->()) {
    indent($indent, sprintf("%-35s  %-30s %-30s\n", $prefix->name(),
			    $prefix->id(), $prefix->description()));
    next if ($prefix->is_stub() and $opt{'no-stub-recurse'});
    if ($prefix->isa('IPAM::Address') and $opt{recurse}
	and $prefix->canonical_host()) {
      name_info($prefix->id(), $indent+1);
    } elsif($opt{recurse}) {
      print_pf_registry($prefix->registry(), $indent+1, $prefix->af());
    }
  }
  $opt{recurse} = $recurse_save;
}

sub alternatives($$$) {
  my ($indent, $type, $host, $thing) = @_;
  if (my ($alt, $state) = $ipam->registry(IPAM::REG_ALTERNATIVE)
      ->find_mapping($type, $host, $thing)) {
    indent($indent+1, "Alternative ".$alt->name().": "
    	   ."$state/".($alt->check_state($state) ? 'active' : 'inactive')."\n")
  }
}

## Local Variables:
## mode: CPerl
## End:
